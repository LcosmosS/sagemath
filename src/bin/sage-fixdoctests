#!/usr/bin/env sage-python

"""
Given the output of doctest and a file, adjust the doctests so they won't fail.

Doctest failures due to exceptions are ignored.

AUTHORS::

- Nicolas M. Thi√©ry <nthiery at users dot sf dot net>  Initial version (2008?)

- Andrew Mathas <andrew dot mathas at sydney dot edu dot au> 2013-02-14
  Cleaned up the code and hacked it so that the script can now cope with the
  situations when either the expected output or computed output are empty.
  Added doctest to sage.tests.cmdline
"""
import os
import re
import shlex
import subprocess

from argparse import ArgumentParser, FileType
from pathlib import Path

from sage.doctest.parsing import update_optional_tags
from sage.env import SAGE_ROOT
from sage.misc.temporary_file import tmp_filename


parser = ArgumentParser(description="Given an input file with doctests, this creates a modified file that passes the doctests (modulo any raised exceptions). By default, the input file is modified. You can also name an output file.")
parser.add_argument('-l', '--long',
                    dest='long', action="store_true", default=False)
parser.add_argument("--distribution", type=str, default='',
                    help="distribution package to test, e.g., 'sagemath-graphs', 'sagemath-combinat[modules]'; sets defaults for --venv and --environment")
parser.add_argument("--venv", type=str, default='',
                    help="directory name of a venv where 'sage -t' is to be run")
parser.add_argument("--environment", type=str, default='',
                    help="name of a module that provides the global environment for tests; implies --keep-both and --full-tracebacks")
parser.add_argument("--full-tracebacks", default=False, action="store_true",
                    help="include full tracebacks rather than '...'")
parser.add_argument("--only-tags", default=False, action="store_true",
                    help="only add '# optional' tags where needed, ignore other failures")
parser.add_argument("--keep-both", default=False, action="store_true",
                    help="do not replace test results; duplicate the test instead and mark both copies # optional")
parser.add_argument("input", help="input filename",
                    type=FileType('r'))
parser.add_argument('output', nargs='?', help="output filename",
                    type=FileType('w'))

args = parser.parse_args()

# set input and output files
test_file = args.input
src_in = test_file.read()
test_file.close()

runtest_default_environment = "sage.repl.ipython_kernel.all_jupyter"

def default_venv_environment_from_distribution():
    if args.distribution:
        # shortcuts / variants
        args.distribution = args.distribution.replace('_', '-')
        if not (args.distribution.startswith('sagemath-')
                or args.distribution.startswith('sage-')):
            args.distribution = f'sagemath-{args.distribution}'
        # extras
        m = re.fullmatch(r'([^[]*)(\[([^]]*)\])?', args.distribution)
        plain_distribution, extras = m.group(1), m.group(3)
        tox_env_name = 'sagepython-sagewheels-nopypi-norequirements'
        if extras:
            tox_env_name += '-' + extras.replace(',', '-')
        default_venv = os.path.join(SAGE_ROOT, 'pkgs', plain_distribution, '.tox', tox_env_name)
        default_environment = 'sage.all__' + plain_distribution.replace('-', '_')
    else:
        default_venv = ''
        default_environment = runtest_default_environment
    return default_venv, default_environment

default_venv, default_environment = default_venv_environment_from_distribution()

if not args.venv:
    args.venv = default_venv
if not args.environment:
    args.environment = default_environment

if args.environment:
    args.keep_both = args.full_tracebacks = True

venv_explainers = []

if args.venv:
    if m := re.search(f'pkgs/(sage[^/]*)/[.]tox/((sagepython|sagewheels|nopypi|norequirements)-*)*([^/]*)$',
                      args.venv):
        args.distribution, extras = m.group(1), m.group(4)
        if extras:
            args.distribution += '[' + extras.replace('-', ',') + ']'
        default_venv_given_distribution, default_environment_given_distribution = default_venv_environment_from_distribution()

        if (Path(args.venv).resolve() == Path(default_venv_given_distribution).resolve()
                or args.environment == default_environment_given_distribution):
            venv_explainers.append(f'--distribution {shlex.quote(args.distribution)}')
            default_venv, default_environment = default_venv_given_distribution, default_environment_given_distribution

if Path(args.venv).resolve() != Path(default_venv).resolve():
    venv_explainers.append(f'--venv {shlex.quote(args.venv)}')
if args.environment != default_environment:
    venv_explainers.append(f'--environment {args.environment}')

if venv_explainers:
    venv_explainer = ' (with ' + ' '.join(venv_explainers) + ')'
else:
    venv_explainer = ''

# put the output of the test into sage's temporary directory
doc_file = tmp_filename()
cmdline = '%s -t %s %s %s > %s' % (
    shlex.quote(f'{args.venv}/bin/sage') if args.venv else 'sage',
    '--long' if args.long else '',
    f'--environment {args.environment}' if args.environment != runtest_default_environment else '',
    test_file.name, doc_file)
print(f'Running {cmdline}')
os.system(cmdline)

with open(doc_file, 'r') as doc:
    doc_out = doc.read()
sep = "**********************************************************************\n"

doctests = doc_out.split(sep)
src_in_lines = src_in.splitlines()

for block in doctests:
    # Extract the line, what was expected, and was got.
    line = block.find('line ')             # block should contain:  'line ##, in ...', where ## is an integer
    comma = block.find(', in ')            # we try to extract the line number which gives the test failure
    if line == -1 or comma == -1:
        continue   # but if something goes wrong we give up
    first_line_num = line_num = int(block[line + 5:comma])  # 1-based line number of the first line of the example

    if m := re.search(r"referenced here was set only in doctest marked '# optional - ([^;']*)", block):
        optional = m.group(1)
        src_in_lines[first_line_num - 1] = update_optional_tags(src_in_lines[first_line_num - 1],
                                                                add_tags=[optional])

    if m2 := re.search('(Expected:|Expected nothing|Exception raised:)\n', block):
        m1 = re.search('Failed example:\n', block)
        line_num += block[m1.end() : m2.start()].count('\n') - 1
        # Now line_num is the 1-based line number of the last line of the example

        if m2.group(1) == 'Expected nothing':
            expected = ''
            block = '\n' + block[m2.end():]  # so that split('\nGot:\n') does not fail below
        elif m2.group(1) == 'Exception raised:':
            # In this case, the doctester does not show the expected output,
            # so we do not know how many lines it spans; so we check for the next prompt or
            # docstring end.
            expected = []
            indentation = ' ' * (len(src_in_lines[line_num - 1]) - len(src_in_lines[line_num - 1].lstrip()))
            i = line_num
            while ((not src_in_lines[i].rstrip() or src_in_lines[i].startswith(indentation))
                   and not re.match(' *(sage:|""")', src_in_lines[i])):
                expected.append(src_in_lines[i])
                i += 1
            block = '\n'.join(expected) + '\nGot:\n' + block[m2.end():]
        else:
            block = block[m2.end():]
    else:
        continue

    # Error testing.
    if m := re.search(r"ModuleNotFoundError: No module named '([^']*)'", block):
        optional = m.group(1)
        asked_why = re.search('#.*(why|explain)', src_in_lines[first_line_num - 1])
        # FIXME: map module name to feature name
        src_in_lines[first_line_num - 1] = update_optional_tags(src_in_lines[first_line_num - 1],
                                                                add_tags=[optional])
        if not asked_why:
            # When no explanation has been demanded,
            # we just mark the doctest with the feature
            continue
        # Otherwise, continue and show the backtrace as 'GOT'

    if args.only_tags:
        continue

    if 'Traceback (most recent call last):' in block:

        expected, got = block.split('\nGot:\n')
        if args.full_tracebacks:
            if re.fullmatch(' *\n', got):
                got = got[re.end(0):]
            # don't show doctester internals (anything before first "<doctest...>" frame
            if m := re.search('( *Traceback.*\n *)(?s:.*?)(^ *File "<doctest)( [^>]*)>', got, re.MULTILINE):
                got = m.group(1) + '...\n' + m.group(2) + '...' + got[m.end(3):]
            while m := re.search(' *File "<doctest( [^>]*)>', got):
                got = got[:m.start(1)] + '...' + got[m.end(1):]
            # simplify filenames shown in backtrace
            while m := re.search('"([-a-zA-Z0-9._/]*/site-packages)/sage/', got):
                got = got[:m.start(1)] + '...' + got[m.end(1):]

            last_frame = got.rfind('File "')
            if (last_frame >= 0
                    and (index_NameError := got.rfind("NameError:")) >= 0
                    and got[last_frame:].startswith('File "<doctest')):
                # NameError from top level, so keep it brief
                if m := re.match("NameError: name '(.*)'", got[index_NameError:]):
                    name = ": '" + m.group(1) + "'"
                else:
                    name = ""
                src_in_lines[first_line_num - 1] = update_optional_tags(src_in_lines[first_line_num - 1],
                                                                        add_tags=[f'NameError{name}{venv_explainer}'])
                continue
            got = got.splitlines()
        else:
            got = got.splitlines()
            got = ['Traceback (most recent call last):', '...', got[-1].lstrip()]
    elif block[-21:] == 'Got:\n    <BLANKLINE>\n':
        expected = block[:-22]
        got = ['']
    else:
        expected, got = block.split('\nGot:\n')
        got = got.splitlines()      # got can't be the empty string

    expected = expected.splitlines()

    if args.keep_both:
        test_lines = ([update_optional_tags(src_in_lines[first_line_num - 1],
                                            add_tags=[f'GOT{venv_explainer}'])]
                      + src_in_lines[first_line_num : line_num])
        src_in_lines[first_line_num - 1] = update_optional_tags(src_in_lines[first_line_num - 1],
                                                                add_tags=['EXPECTED'])
        indent = (len(src_in_lines[line_num - 1]) - len(src_in_lines[line_num - 1].lstrip()))
        line_num += len(expected)  # skip to the last line of the expected output
        src_in_lines[line_num - 1] += '\n'.join([''] + test_lines)  # 2nd copy of the test
        # now line_num is the last line of the 2nd copy of the test
        expected = []

    # If we expected nothing, and got something, then we need to insert the line before line_num
    # and match indentation with line number line_num-1
    if not expected:
        indent = (len(src_in_lines[first_line_num - 1]) - len(src_in_lines[first_line_num - 1].lstrip()))
        src_in_lines[line_num - 1] += '\n' + '\n'.join('%s%s' % (' ' * indent, line.lstrip()) for line in got)
        continue

    # Guess how much extra indenting ``got`` needs to match with the indentation
    # of src_in_lines - we match the indentation with the line in ``got`` which
    # has the smallest indentation after lstrip(). Note that the amount of indentation
    # required could be negative if the ``got`` block is indented. In this case
    # ``indent`` is set to zero.
    indent = max(0, (len(src_in_lines[line_num]) - len(src_in_lines[line_num].lstrip())
                     - min(len(got[j]) - len(got[j].lstrip()) for j in range(len(got)))))

    # Double check that what was expected was indeed in the source file and if
    # it is not then then print a warning for the user which contains the
    # problematic lines.
    if any(expected[i].strip() != src_in_lines[line_num + i].strip()
           for i in range(len(expected))):
        import warnings
        txt = "Did not manage to replace\n%s\n%s\n%s\nwith\n%s\n%s\n%s"
        warnings.warn(txt % ('>' * 40, '\n'.join(expected), '>' * 40,
                             '<' * 40, '\n'.join(got), '<' * 40))
        continue

    # If we got something when we expected nothing then we delete the line from the
    # output, otherwise, add all of what we `got` onto the end of src_in_lines[line_num]
    if got == ['']:
        src_in_lines[line_num] = None
    else:
        src_in_lines[line_num] = '\n'.join((' ' * indent + got[i])
                                           for i in range(len(got)))

    # Mark any remaining `expected` lines as ``None`` so as to preserve the line numbering
    for i in range(1, len(expected)):
        src_in_lines[line_num + i] = None

# Overwrite the source (or output file specified on the command line)
if args.output:
    test_output = args.output
else:
    test_output = open(test_file.name, 'w')

for line in src_in_lines:
    if line is None:
        continue
    test_output.write(line)
    test_output.write('\n')

test_output.close()

# Show summary of changes
if args.output:
    print('The fixed doctests have been saved as {0}.'.format(test_output.name))
else:
    relative = os.path.relpath(test_output.name, SAGE_ROOT)
    print(relative)
    if relative.startswith('..'):
        print('Fixed source file is not part of Sage.')
    else:
        subprocess.call(['git', '--no-pager', 'diff', relative], cwd=SAGE_ROOT)
