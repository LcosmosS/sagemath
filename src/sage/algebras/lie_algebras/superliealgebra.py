r"""
Super Lie Algebras

These are `K`-graded Lie algebras satisfying graded antisymmetry and
the graded Jacobi identity, where there is a natural map `K \to \ZZ / 2 \ZZ`.

Note that these are more commonly referred to as Lie superalgebras in the
literature.

AUTHORS:

- Aditya Dwarkesh, Martin Frankland (08-08-2023): Initial version
"""

# ****************************************************************************
#       Copyright (C) 2023 Aditya Dwarkesh <ad19ms047@iiserkol.ac.in>
#                          Martin Frankland <Martin.Frankland@uregina.ca>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#                  https://www.gnu.org/licenses/
# ****************************************************************************

from sage.combinat.free_module import CombinatorialFreeModule
from sage.misc.cachefunc import cached_method
from sage.structure.indexed_generators import standardize_names_index_set
from sage.sets.family import Family
from sage.categories.lie_algebras import LieAlgebras

class SuperLieAlgebra(CombinatorialFreeModule):
    """
    A super Lie algebra.

    Currently this only supports finite dimensional Lie superalgebras
    specified by their structure coefficients with integer degrees for
    each basis element.

    INPUT:

    - ``R`` -- the base ring
    - ``s_coeff`` -- the structure coefficients
    - ``names`` -- (optional) the names of the basis elements
    - ``index_set`` -- (optional) the indices of the basis elements
    - ``degrees`` -- (default: all 0) list of degrees of the basis elements

    EXAMPLES::

        sage: d = {('x','y'): {'z':1}}
        sage: L.<x,y,z> = SuperLieAlgebra(QQ, s_coeff=d, degrees=(1,1,2))  # corresponding to Q^2 + Q
    """
    @staticmethod
    def __classcall_private__(cls, R, s_coeff, degrees=None, names=None, index_set=None, **kwargs):
        """
        Normalize input to ensure a unique representation.
        """
        if names is None:
            if degrees is None:
                raise ValueError("you must specify names or degrees")
            else:
                n = len(degrees)
            names = tuple('x{}'.format(i) for i in range(n))
        elif isinstance(names, str):
            names = tuple(names.split(','))
            n = len(names)
        else:
            n = len(names)
            names = tuple(names)

        if degrees is None:
            degrees = tuple([0] * n)

        degrees = tuple(degrees)
        names, index_set = standardize_names_index_set(names, index_set)
        s_coeff = _standardize_s_coeff(s_coeff, index_set, degrees)

        return super().__classcall__(cls, R, s_coeff, degrees, names, index_set, **kwargs)

    def __init__(self, R, s_coeff, degrees, names, index_set, category=None, **kwds):
        """
        Initialize ``self``.

        EXAMPLES::

            sage: L.<x,y,z> = SuperLieAlgebra(QQ, {('x','y'):{'z':1}}, (1,1,2))
            sage: TestSuite(L).run()
        """
        if names is not None:
            kwds['prefix'] = kwds.get('prefix', '')
            kwds['bracket'] = kwds.get('bracket', '')
            kwds['string_quotes'] = kwds.get('string_quotes', False)
        self._degrees = dict(zip(index_set, degrees))
        category = LieAlgebras(R).WithBasis().FiniteDimensional().Super().or_subcategory(category)

        CombinatorialFreeModule.__init__(self, R, index_set, category=category, **kwds)

        self._s_coeff = {k: self.element_class(self, dict(s_coeff[k])) for k in s_coeff.keys()}

    def _test_degree(self, **options):
        """
        Test to ensure that the bracket satisfies the grading property.
        """
        tester = self._tester(**options)
        for ii,i in enumerate(self._indices):
            for j in self._indices[ii+1:]:
                k = (i, j)
                if (i, j) in self._s_coeff:
                    tester.assertTrue(self._s_coeff[k].is_homogeneous())
                    tester.assertEqual(self._degrees[i] + self._degrees[j], self._s_coeff[k].degree())

    def _repr_(self):
        """
        Return a string representation of ``self``.

        EXAMPLES::

            sage: L.<x,y,z> = SuperLieAlgebra(QQ, {('x','y'):{'z':1}}, (1,1,2))
            sage: L
            Super Lie algebra generated by (x, y, z) over Rational Field
        """
        return "Super Lie algebra generated by {} over {}".format(self.gens(), self.base_ring())

    def __getitem__(self, x):
        """
        If ``x`` is a pair `(a, b)`, return the Lie bracket `[a, b]
        (including if `a` or `b` are Lie (sub)algebras, in which case the
        corresponding ideal is constructed).
        Otherwise try to return the `x`-th element of ``self``.

        EXAMPLES::

            sage: L.<x,y,z> = SuperLieAlgebra(QQ, {('x','y'):{'z':1}}, (1,1,2))
            sage: L[x, y]
            z
        """
        if isinstance(x, tuple) and len(x) == 2:
            # Check if we need to construct an ideal
            Cat = LieAlgebras.Super
            if x[0] in Cat:
                if x[1] in Cat:
                    #return x[0].product_space(x[1])
                    raise NotImplementedError("sup Lie superalgebras not yet implemented")
                #return x[0].ideal(x[1])
                raise NotImplementedError("ideals not yet implemented")
            elif x[1] in Cat:
                #return x[1].ideal(x[0])
                raise NotImplementedError("ideals not yet implemented")
            # Otherwise it is the bracket of two elements
            return self(x[0])._bracket_(self(x[1]))
        return super().__getitem__(x)


    def _element_constructor_(self, x):
        r"""
        Convert ``x`` into ``self``.

        EXAMPLES::

            sage: L.<x,y> = LieAlgebra(QQ, representation="polynomial")
            sage: elt = L([x, y]); elt
            x*y - y*x
            sage: elt.parent() is L
            True

        TESTS:

        Check that `0` gives the zero element::

            sage: L = lie_algebras.pwitt(GF(5), 5)
            sage: L(0)
            0
        """
        if isinstance(x, list) and len(x) == 2:
            return self(x[0])._bracket_(self(x[1]))

        if x == 0:
            return self.zero()

        try:
            if x in self.module():
                return self.from_vector(x)
        except AttributeError:
            pass

        if x in self.base_ring():
            # We have already handled the case when x == 0
            raise ValueError("can only convert the scalar 0 into a Lie algebra element")

        return super()._element_constructor_(x)

    @cached_method
    def module(self):
        """
        Return a dense (ungraded) module corresponding to ``self``.
        """
        from sage.modules.free_module import FreeModule
        return FreeModule(self.base_ring(), len(self.basis()))

    def degree_on_basis(self, x):
        """
        Return the degree of the basis element indexed by ``x``.
        """
        return self._degrees[x]

    # Morphisms of graded Lie algebras:

    def graded_morphism(self, on_generators, domain, codomain, argument):
        r"""
        Return a graded morphim of super Lie algebras.

        EXAMPLES::

            sage: L.<x,y,z> = SuperLieAlgebra(QQ, {('x','y'):{'z':1}}, (1,1,2))
            sage: L.graded_morphism({x:x, y:y, z:z}, L, L, x.bracket(y))
            (0, 0, 1)
        """
        from itertools import combinations
        from sage.matrix.constructor import matrix

        m = domain.module()
        cm = codomain.module()
        on_gens_input = list(on_generators)
        on_gens_image = list(on_generators.values())

        spanning_set = [X.to_vector() for X in on_gens_input]
        im_gens = [Y.to_vector() for Y in on_gens_image]
        R = self.base_ring()

        def solve_linear_system(A, b):
            A_inv = A.solve_left(matrix.identity(A.ncols()))
            M = A * A_inv
            for Mi, bk in zip(M.rows(), b):
                test_bk = cm.sum(R(Mij) * bj for Mij, bj in zip(Mi, b))
                if test_bk != bk:
                    raise ValueError("contradictory linear system")

            return [cm.sum(R(Aij) * bk for Aij, bk in zip(Ai, b))
                    for Ai in A_inv.rows()]

        bracketlength = 1
        n = 0
        while True:
            sm = m.submodule(spanning_set)
            A = matrix(sm.base_ring(), [sm.coordinate_vector(X) for X in spanning_set])
            try:
                im_gens = solve_linear_system(A, im_gens)
            except ValueError:
                raise ValueError("this does not define a graded Lie algebra morphism")

            spanning_set = list(sm.basis())
            if n == len(spanning_set):
                break

            bracketlength += 1
            n = len(spanning_set)
            for i, j in combinations(range(n), 2):
                Z = on_gens_input[i].bracket(on_gens_input[j])
                imZ = on_gens_image[i].bracket(on_gens_image[j])
                spanning_set.append(Z.to_vector())
                im_gens.append(imZ.to_vector())

        A = matrix(m.base_ring(), spanning_set)
        im_gens = solve_linear_system(A, im_gens)

        return cm.sum(c * im_gens[i] for i, c in argument.to_vector().items())

    class Element(CombinatorialFreeModule.Element):
        def _bracket_(self, rt):
            """
            Return the Lie bracket ``[self, rt]``.

            EXAMPLES::

                sage: L.<x,y,z> = SuperLieAlgebra(QQ, {('x','y'):{'z':1}}, (1,1,2))
                sage: x.bracket(y)
                z
                sage: y.bracket(x)
                z
            """
            P = self.parent()

            if not self or not rt:
                return P.zero()

            s_coeff = P._s_coeff
            degrees = P._degrees

            def get_elt(bl, br):
                if (bl, br) in s_coeff:
                    return s_coeff[bl, br]
                if (br, bl) not in s_coeff:
                    return None
                if degrees[bl] * degrees[br] % 2:
                    return s_coeff[br, bl]
                return -s_coeff[br, bl]

            return P.sum(cl * cr * elt
                         for bl,cl in self._monomial_coefficients.items()
                         for br,cr in rt._monomial_coefficients.items()
                         if (elt := get_elt(bl, br)))


def _standardize_s_coeff(s_coeff, index_set, degrees):
    """
    Helper function to standardize ``s_coeff`` into the appropriate form
    (dictionary indexed by pairs, whose values are dictionaries).

    Strips items with coefficients of 0 and duplicate entries.
    This does not check the (super) Jacobi relation (nor antisymmetry
    if the cardinality is infinite).

    INPUT:

    - ``s_coeff`` -- ``dict`` whose keys are pairs of indices with corresponding
      value being a ``dict`` representing the bracket
    - ``index_set`` -- tuple of the indices
    - ``degrees`` -- tuple of degrees of the corresponding basis elements

    EXAMPLES::

        sage: from sage.algebras.lie_algebras.superliealgebra import _standardize_s_coeff
        sage: d = {('y', 'x'): {'x': -1}}
        sage: _standardize_s_coeff(d, ('x', 'y'), (0, 0))
        Finite family {('x', 'y'): (('x', 1),)}
        sage: _standardize_s_coeff(d, ('x', 'y'), (1, 0))
        Finite family {('x', 'y'): (('x', 1),)}
        sage: _standardize_s_coeff(d, ('x', 'y'), (0, 1))
        Finite family {('x', 'y'): (('x', 1),)}
        sage: _standardize_s_coeff(d, ('x', 'y'), (1, 1))
        Finite family {('x', 'y'): (('x', -1),)}
    """
    # Try to handle infinite basis (once/if supported)
    #if isinstance(s_coeff, AbstractFamily) and s_coeff.cardinality() == infinity:
    #    return s_coeff

    index_to_pos = {k: i for i, k in enumerate(index_set)}

    sc = {}
    # Make sure the first gen is smaller than the second in each key
    for k in s_coeff.keys():
        v = s_coeff[k]
        if isinstance(v, dict):
            v = v.items()
        i0 = index_to_pos[k[0]]
        i1 = index_to_pos[k[1]]
        d0 = degrees[i0]
        d1 = degrees[i1]

        if i0 > i1:
            key = (k[1], k[0])
            vals = tuple((g, (-1)**(d0*d1+1) * val) for g, val in v if val)
        else:
            if not i0 < i1:
                if k[0] == k[1] and d0 * d1 % 2 == 0:
                    if any(val for g, val in v):
                        raise ValueError("elements {} are equal but their bracket is not set to 0".format(k))
                    continue
            key = tuple(k)
            vals = tuple((g, val) for g, val in v if val)

        if key in sc.keys() and sorted(sc[key]) != sorted(vals):
            raise ValueError("two distinct values given for one and the same bracket")

        if vals:
            sc[key] = vals
    return Family(sc)
